import os
import re
import requests
import requests.utils

from gtork import config


class GarminException(Exception):
    pass


class Garmin(object):

    login_url = "https://sso.garmin.com/sso/login?service=https%3A%2F%2Fconnect.garmin.com%2Fpost-auth%2Flogin"
    post_login_url = "https://connect.garmin.com/post-auth/login"
    activity_url = "https://connect.garmin.com/modern/proxy/activitylist-service/activities/search/activities?limit=20&start=0"
    data_url = "https://connect.garmin.com/modern/proxy/download-service/export/{}/activity/{}"

    def __init__(self):
        self._logged_in = False

        self._session = requests.Session()
        self._session.headers.update({'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.71 Safari/537.36'})

    def reload_state(self, state):
        """
        Reload a previous state generated by Garmin.get_state()
        :param state:
        :return:
        """
        self._logged_in = state['logged_in']
        requests.utils.add_dict_to_cookiejar(self._session.cookies, state['request_cookies'])

    def login(self, username, password):

        # Initally make a get request to the login service to get a session id
        r = self._make_request(self.login_url, human_action="fetching the base login URL")

        # Now we post the login details, along with some extra form information identified in manual inspection
        post_data = {
            "username": username,
            "password": password,
            "embed": "true",
            "lt" : "els1",
            "_eventId" : "submit",
            "displayNameRequired": "false"
        }

        r = self._make_request(self.login_url, post=True, human_action="posting the login data", data=post_data)

        # Finally, Garmin require us to make a further request with a ticket extracted from this response
        ticket_matches = re.findall(re.escape('?ticket=') + '[^"]*', r.text)
        if len(ticket_matches) != 1 or len(ticket_matches[0]) < len('?ticket='):
            raise GarminException("Could not extract ticket from login response, username/password may be incorrect")

        url = self.post_login_url + ticket_matches[0]
        r = self._make_request(url, human_action="confirming the Garmin ticket")

        self._logged_in = True

    def fetch_activities(self):
        r = self._make_request(self.activity_url, human_action="fetching the activity URL", login_required=True)
        if config.DEV:
            import json
            with open('/tmp/garmin.json', 'w') as fh:
                json.dump(r.json(), fh)
        return r.json()

    def download_activity(self, activity_id, data_dir):

        for ext in ['gpx', 'tcx']:
            url = self.data_url.format(ext, activity_id)
            r = self._make_request(url, human_action="downloading {} data".format(ext), login_required=True)
            output_file = os.path.join(data_dir, activity_id +  '.' + ext)
            with open(output_file, 'wb') as h:
                h.write(r.content)

    def _make_request(self, url, post=False, human_action='connecting to garmin', login_required=False, **kwargs):
        """
        Make a get or post request to the supplied url, passing kwargs to the approriate requests method.
        GarminException is raised if the response fails, using the human_action to describe it.

        Returns the response object
        """
        if login_required and not self._logged_in:
            raise GarminException("Must be logged in when {}".format(human_action))

        fn = self._session.get
        if post:
            fn = self._session.post

        try:
            r = fn(url, **kwargs)
            if r.status_code != 200:
                raise GarminException(
                    "Unsuccessful request when {}. Received response {:d}".format(human_action, r.status_code))
            return r
        except requests.Timeout:
            raise GarminException("Timeout when {}".format(human_action))
        except requests.RequestException:
            raise GarminException("Request failure when {}".format(human_action))

    def get_state(self):
        """
        Return the state of the Garmin object so that it can saved
        and reloaded upon a future request
        :return: A dictionary of the state of the Garmin object
        """
        state = {'logged_in': self._logged_in,
                   'request_cookies': requests.utils.dict_from_cookiejar(self._session.cookies)}
        return state
